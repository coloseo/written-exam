<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        pre{
            width: 70%;
            margin:20px auto;
        }
    </style>
</head>

<body>
    <pre>
    * types & grammar
  1. 判断以下结果
     #+BEGIN_SRC javascript
     var s = 'abc';
     s[1] = 'B';
     
     console.log(s);

     var l = new String('abc');
     l[1] = 'B';
     console.log(l);
     
     #+END_SRC

      (1).'abc'
     (2).对象类型的'abc'

  2. 如何逆序一个字符串？
   /**
   * 第一题
   * @param {String} str 
   * @returns {String}
   */
   function reverse(str) {
      if (str.length === 0) {
         return ''
      }
      return str.substr(str.length - 1, 1) + reverse(str.substr(0, str.length - 1))
   }
  3. 接上，为什么不能直接使用
     #+BEGIN_SRC javascript
     Array.prototype.reverse.call(str)
     #+END_SRC
     逆序字符串？

   因为字符串在用下标读取的时候会有一个自动的类型转换为包装类的字符对象，而这个对象是只读的，读取之后这个对象会自动销毁

  4. 判断以下结果，为什么会出现这样的情况，如何做出正确的比较？
     #+BEGIN_SRC javascript
     0.1 + 0.2 === 0.3;
     0.8 - 0.6 === 0.3;
     #+END_SRC
     
   因为js中数字都是双精度的浮点型，所以计算后会有小数后面的不精准，两个数可以乘以一定的相同倍数在做比较

  5. 如何判断一个数值为整数？

  6. 如何判断一个数值为+0？
   可以用Object.is这个方法，+0和0判断会是true，和-0判断为false;
  7. 以下代码中'abc'作为primitive value, 如何访问toUpperCase 方法?
     #+BEGIN_SRC javascript
     'abc'.toUpperCase();
     #+END_SRC

   他内部会把字符串转换为包装类字符串对象，然后就可以调用方法

  8. 判断以下结果
     #+BEGIN_SRC javascript
     Array.isArray(Array.prototype);
     #+END_SRC

      true

  9. 判断以下结果
     #+BEGIN_SRC javascript
     Boolean(Boolean(false));
     Boolean(document.all);
     [] == '';
     [3] == 3;
     [] == false;
     42 == true;
     #+END_SRC

     false
     false
     true
     true
     true
     false

  10. 找出以下代码问题(TDZ)
      #+BEGIN_SRC javascript
      var a = 3;
      let a;
      #+END_SRC

      变量重复声明，let声明变量当前作用域只能声明一次

  11. 找出以下代码问题(TDZ)
      #+BEGIN_SRC javascript
      var b = 3;
      function foo(a = 42, b = a + b + 5) {
        // ..
      }
      
      foo();
      #+END_SRC

      函数形参b赋值里面的b并不是全局的b，所以就是未初始化就是用报错

* scope & closures

  1. var a = 2 中, Engine, Scope, Compiler 做了什么工作?

  2. 判断以下结果(lexical scope)
     #+BEGIN_SRC javascript
     var scope = 'global scope';
     function checkscope() {
         var scope = 'local scope';
         function f() {
           return scope;
         }
         return f;
     }
     #+END_SRC

   函数f执行返回'local scope'

  3. 判断以下结果(Hoisting)
     #+BEGIN_SRC javascript
     console.log(a);
     var a = 3;
     #+END_SRC

   undefined

  4. 判断以下结果(Function First)
     #+BEGIN_SRC javascript
     var foo = 1;
     function foo() {}
     console.log(foo);
     #+END_SRC

      1

  5. 判断以下结果(IIFE & Function First)
     #+BEGIN_SRC javascript
     var foo = 1;
     (function () {
       foo = 2;
       function foo (){
       }
       console.log(foo);
     })()
     console.log(foo);
     #+END_SRC

     2
     1

  6. 判断以下结果，如何按序输出(Closure)
     #+BEGIN_SRC javascript
     for (var i = 0; i < 10; i++) {
       setTimeout(function () {
         console.log(i);
       }, i * 1000);
     }
     #+END_SRC

      方法1：
      在setTimeout外面套一层立即执行函数把i传参进去
      方法2：把for循环里的var关键字改成let

* this & object prototypes
  1. 判断以下结果(Default Binding)
     #+BEGIN_SRC javascript
     function foo() {
       "use strict"
       console.log(this.a);
     }
     var a = 2;
     
     foo();
     #+END_SRC

   报错，在严格模式下函数内部的this是undefined

  2. 判断以下结果
     #+BEGIN_SRC javascript
     "use strict"
     var a = 2;
     console.log(this);
     #+END_SRC

      输出window对象

  3. 判断以下结果(strict mode & default binding)
     #+BEGIN_SRC javascript
     function foo() {
       console.log(this.a);
     }
     var a = 2;
     (function(){
       "use strict"
       foo();
     })();
     #+END_SRC

      输出结果为2

  4. 判断以下结果(hard binding)
     #+BEGIN_SRC javascript
     function foo() {
       console.log(this.a);
     }
     const o1 = { a: 3 };
     const o2 = { a: 4 };

     foo.bind(o1).bind(o2)();
     #+END_SRC

      输出结果为3

  5. 如何实现
     #+BEGIN_SRC javascript
     Function.prototype.bind
     Function.prototype.softBind
     #+END_SRC

     Function.prototype.bind = function (context,...arg1){
        let self = this;
         return function(...arg2){
            self.apply(context,[...arg1,...arg2])
         }
     }
      第二个不太明白题啥意思

  6. new 的过程中发生了什么, 判断以下结果(new)
     #+BEGIN_SRC javascript
     function F() {
       this.a = 3;
       return {
         a: 4
       }
     }
     const f = new F();
     console.log(f.a);
     #+END_SRC

      入栈，创建作用域，this指向一个新对象，执行函数体，给this赋值，然后隐式的返回this；
      输出4，因为显示的返回了一个对象，就会使用该对象

  7. 什么是data descriptor 和 accessor descriptor?
  
  data descriptor是属性描述符；用来配置一个对象的属性是否可迭代，是否可赋值，是否可配置删除；
  accessor descriptor访问器属性：get和set用来控制赋值和获取属性值，然后还可以配置是否可迭代，是否可配置删除；


  8. 如何访问一个对象的属性与如何对一个对象的属性赋值(Get & Put)?

   可以使用(对象名加.属性名的方式)|(对象名[属性名的表达式])获取
   赋值的话就是上面的两种方式后面加上赋值(= 需要赋的值)

  9. 如何遍历一个对象(iterator)?

  10. 如何实现一个继承(Object.create & call)?
   function A (){}
   function B (name){
      A.call(this,name);
   }
   B.prototype = Object.create(A.prototype);
   B.prototype.constuctor = B
  11. 如何实现 __proto__?
   Object.defineProperty(Object.prototype, '__proto__', {
    get() {
       let _thisObj = Object (this);
       return Object.getPrototypeOf(_thisObj);
   },
   set(proto) {
       if (typeOf proto != 'object') {
           return undefined;
       }
       Reflect.setPrototypeOf(this, proto);
   },
});
  
    12. 如何实现Object.create?
    Object.create = function(obj){
        if(typeOf obj != 'object'){
           return {}
        }
        let newObj = {};
        Reflect.setPrototypeOf(newObj, obj);
        return newObj;
  }
  </pre>

</body>

</html>