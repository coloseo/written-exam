<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>笔试题</title>
</head>
<body>
<script>
    // 1 编写一个递归版本的 reverse(s) 函数(或方法),以将字符串s倒置。
    let str = 'hello word';
    console.log(reverse(str));

    function reverse(s) {
        let arr = s.split('')
        changeStr(arr, arr.length)
        return arr.join('')
    }

    function changeStr(arr, len) {
        if (len > 1) {
            for (let i = 0; i < len - 1; i++) {
                let temp = arr[i];
                arr[i] = arr[i + 1]
                arr[i + 1] = temp
            }
            len--;
            changeStr(arr, len)
        }
        return arr
    }

    // 2 编写程序 expr，以计算从命令行输入的逆波兰表达式的值，其中每个运算符或操作数用一个单独的参数表示。例如，命令 expr 2 3 4 + *

    console.log(expr('2 3 4 + *'));

    function expr(expr) {
        if (!expr) return 0;  //字符串为空，返回0
        let arr = expr.split(' ')
        let elems = []
        let item;
        while (item = arr.shift()) {
            if (!isNaN(+item)) {
                elems.push(+item)
            } else {
                let res = count(item, elems.pop(), elems.pop())
                elems.push(res)
            }
        }
        return elems.pop()
    }
    //  运算符计算
    function count(opera, num1, num2) {
        switch (opera) {
            case '+':
                return num2 + num1
            case '-':
                return num2 - num1
            case '*':
                return num2 * num1
            case '/':
                return num2 / num1
        }
    }

    // 3 用归并排序将3，1，4，1，5，9，2，6 排序。
    let arr = [3, 1, 4, 1, 5, 9, 2, 6]
    let resArr = merge_sort(arr)
    console.log(resArr);

    function merge_sort(arr) {
        if (arr.length == 1)
            return arr
        var mid = Math.floor(arr.length / 2)
        var left = arr.slice(0, mid)
        var right = arr.slice(mid)
        return Merger(merge_sort(left), merge_sort(right)); //合并左右部分
    }

    function Merger(a, b) {
        var n = a && a.length;
        var m = b && b.length;
        var c = [];
        var i = 0, j = 0;
        while (i < n && j < m) {
            if (a[i] < b[j])
                c.push(a[i++]);
            else
                c.push(b[j++]);
        }
        while (i < n)
            c.push(a[i++]);
        while (j < m)
            c.push(b[j++]);
        return c;
    }

    // 4 对下面的 json 字符串 serial 相同的进行去重。
    let json1 = [
        {"name": "张三", "serial": "0001"},
        {"name": "李四", "serial": "0002"},
        {"name": "王五", "serial": "0003"},
        {"name": "王五2", "serial": "0003"},
        {"name": "赵四", "serial": "0004"},
        {"name": "小明", "serial": "005"},
        {"name": "小张", "serial": "006"},
        {"name": "小李", "serial": "006"},
        {"name": "小李2", "serial": "006"},
        {"name": "赵四2", "serial": "0004"}
    ];
    let newJson1 = handleSerial(json1)
    console.log(newJson1);

    function handleSerial(s) {
        if (s.length > 1) {
            for (let i = 0; i < s.length - 1; i++) {  //用到i+1,所以i<s.length-1
                for (let j = i + 1; j < s.length; j++) { //从i+1开始比对
                    if (s[i].serial == s[j].serial) {
                        s.splice(j, 1); //删除j位置的数据项，就有后面的元素替补，所以要退一步
                        j--;
                    }
                }
            }
        }
        return s;
    }

    // 5 把下面给出的扁平化json数据用递归的方式改写成组织树的形式
    let city = [
        {"id": "1", "name": "中国", "code": "110", "parent": ""},
        {"id": "2", "name": "北京市", "code": "110000", "parent": "110"},
        {"id": "3", "name": "河北省", "code": "130000", "parent": "110"},
        {"id": "4", "name": "四川省", "code": "510000", "parent": "110"},
        {"id": "5", "name": "石家庄市", "code": "130001", "parent": "130000"},
        {"id": "6", "name": "唐山市", "code": "130002", "parent": "130000"},
        {"id": "7", "name": "邢台市", "code": "130003", "parent": "130000"},
        {"id": "8", "name": "成都市", "code": "510001", "parent": "510000"},
        {"id": "9", "name": "简阳市", "code": "510002", "parent": "510000"},
        {"id": "10", "name": "武侯区", "code": "51000101", "parent": "510001"},
        {"id": "11", "name": "金牛区", "code": "51000102", "parent": "510001"}
    ];
    console.log(fnTree(city));

    function fnTree(s) {
        let ind = 0; //判断第一层是不是还有子树
        if (s.length > 1) {
            for (let i = 0; i < s.length; i++) {
                let a = 0;  //计数信号量
                for (let j = i + 1; j < s.length; j++) {
                    if (s[j].parent == s[i].code) {//判断是否有子树
                        a++;  //子树计数
                        ind++;
                    }
                }
                if (a == 0 && s[i].parent != '') { //没有子树，即树的最底层
                    for (let n in s) {
                        //定义children，避免undefined
                        s[n].children = s[n].children ? s[n].children : [];
                        if (s[n].code == s[i].parent) {
                            s[n].children.push(s[i]);
                        }
                    }
                    s.splice(i, 1);//删除，该子树已经加入了某项底层
                    i--; //删掉子树后后面的数据会填补空缺，退一步才能遍历完全
                }
            }
            if (ind != 0) { //如果还有子树继续遍历第一层
                fnTree(s);
            }
        }
        return s;
    }
</script>
</body>
</html>