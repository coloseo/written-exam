<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>胡梦蝶  面试题</title>
</head>
<body>
    <script>
        //编写一个递归版本的 reverse(s) 函数(或方法),以将字符串s倒置。
        function reverse(s){
            if(s == ""){
                return "";
            }else{
                return reverse(s.substr(1)) + s.charAt(0);
            }
        }
        console.log(reverse("hello world"));  //dlrow olleh

       /* 编写程序 expr，以计算从命令行输入的逆波兰表达式的值，其中每个运算符或操作数用一个单独的参数表示。例如，命令
        expr 2 3 4 + * */

<<<<<<< HEAD
        function expr(arr){
            var reg=/[\+,\-,\*,\/,\%]/;		//-一定要转义，不然不能识别
            if(arr.length>1){   //length要么1要么一定大于等于3
                for(var i=2;i<arr.length;i++){  //第一个数一定是数字。
                    if(reg.test(arr[i])){ //判断是否是运算符，
                        var x = arr[i-2]+arr[i]+arr[i-1];	//拼接字符
                        //eval字符串转表达式运算返回运算值
                        arr.splice(i-2,3,(eval(x)+'')); //删除i-2到i的三项并用计算值替代
                        // console.log(arr[i-2]);
                        expr(arr); //直到只有一个数，即得出结果返回
                    }
                }
            }
            return arr;
        }

        //输入值为‘2 3 4 + *’类似的空格分割的表达式字符串
        function handleExpr(s){
            var arr = s.split(' ');//分割字符串为数组，以空格为单位
            var a = expr(arr); //返回值是数组
            // console.log(a[0]);
            return a[0];
        }
        document.write(handleExpr("2 3 4 + *"));//14


=======
>>>>>>> 769a1f014c20c06faa87e6b7c865d66162db3546

        // 用归并排序将3，1，4，1，5，9，2，6 排序。
            var arr=[3,1,4,1,5,9,2,6 ];
            function merge(left, right) {
                var result = [];
                while(left.length > 0 && right.length > 0) {
                    if(left[0] < right[0]) {
                        result.push(left.shift());
                    }
                    else {
                        result.push(right.shift());
                    }
                }
                /* 当左右数组长度不等.将比较完后剩下的数组项链接起来即可 */
                return result.concat(left).concat(right);
            }
            // 合并分类
            function mergeSort(arr){
                if(arr.length==1) {
                    return arr
                };
                var mid=Math.floor(arr.length/2);
                var left_arr =arr.slice(0,mid);
                var right_arr=arr.slice(mid);
                // console.log(left_arr);
                // console.log(right_arr);
                return merge(mergeSort(left_arr),mergeSort(right_arr));
            }
           console.log(mergeSort(arr));
<<<<<<< HEAD
=======

>>>>>>> 769a1f014c20c06faa87e6b7c865d66162db3546
        function sortNumber(a,b)
        {
            return a - b
        }
<<<<<<< HEAD
        document.write("<br/>"+arr.sort(sortNumber));
=======
        document.write(arr.sort(sortNumber));
>>>>>>> 769a1f014c20c06faa87e6b7c865d66162db3546

        // 对下面的 json 字符串 serial 相同的进行去重。
       var arr_json = [{
            "name": "张三",
            "serial": "0001"
        }, {
            "name": "李四",
            "serial": "0002"
        }, {
            "name": "王五",
            "serial": "0003"
        }, {
            "name": "王五2",
            "serial": "0003"
        }, {
            "name": "赵四",
            "serial": "0004"
        }, {
            "name": "小明",
            "serial": "005"
        }, {
            "name": "小张",
            "serial": "006"
        }, {
            "name": "小李",
            "serial": "006"
        }, {
            "name": "小李2",
            "serial": "006"
        }, {
            "name": "赵四2",
            "serial": "0004"
        }];
        for (var i = 0; i < arr_json.length; i++) {
            for (var j =i+1; j <arr_json.length;) {
                if ( arr_json[i].serial == arr_json[j].serial ) {
                    arr_json.splice(j, 1);
                }
                else{
                    j++;
                }
            }
        }
        console.log(arr_json);

        // 把下面给出的扁平化json数据用递归的方式改写成组织树的形式
<<<<<<< HEAD
        var s = [{
                "id": "1",
                "name": "中国",
                "code": "110",
                "parent": ""
            },{
                "id": "2",
                "name": "北京市",
                "code": "110000",
                "parent": "110"
            },{
                "id": "3",
                "name": "河北省",
                "code": "130000",
                "parent": "110"
            },{
                "id": "4",
                "name": "四川省",
                "code": "510000",
                "parent": "110"
            },{
                "id": "5",
                "name": "石家庄市",
                "code": "130001",
                "parent": "130000"
            },{
                "id": "6",
                "name": "唐山市",
                "code": "130002",
                "parent": "130000"
            },{
                "id": "7",
                "name": "邢台市",
                "code": "130003",
                "parent": "130000"
            },{
                "id": "8",
                "name": "成都市",
                "code": "510001",
                "parent": "510000"
            },{
                "id": "9",
                "name": "简阳市",
                "code": "510002",
                "parent": "510000"
            },{
                "id": "10",
                "name": "武侯区",
                "code": "51000101",
                "parent": "510001"
            },{
                "id": "11",
                "name": "金牛区",
                "code": "51000102",
                "parent": "510001"
            }];
        function Tree(s){
            var ind = 0 ; //判断第一层是不是还有子树
            if(s.length>1){
                for(var i=0;i<s.length;i++){
                    var a = 0;  //计数信号量
                    for(var j=i+1;j<s.length;j++){
                        if(s[j].parent == s[i].code){//判断是否有子树
                            a++;  //子树计数
                            ind++;
                        }
                    }
                    if(a == 0&&s[i].parent!=''){ //没有子树，即树的最底层
                        for(var n in s){
                            //定义children，避免undefined
                            s[n].children = s[n].children?s[n].children:[];
                            if(s[n].code == s[i].parent){
                                s[n].children.push(s[i]);
                            }
                        }
                        s.splice(i,1);//删除，该子树已经加入了某项底层
                        i--; //删掉子树后后面的数据会填补空缺，退一步才能遍历完全
                    }
                }
                if(ind != 0){ //如果还有子树继续遍历第一层
                    Tree(s);
                }
            }
            return s;
        }
        function handleTree(s){
            s = Tree(s);
            console.log(s);
            return s;
        }
        console.log(handleTree(s));
=======
       


>>>>>>> 769a1f014c20c06faa87e6b7c865d66162db3546

    </script>


</body>
</html>